{"code":0,"data":{"records":[{"id":"1780838173472006145","title":"缓存穿透、缓存击穿、缓存雪崩的场景以及解决方法","description":"缓存穿透、缓存击穿、缓存雪崩的场景以及解决方法","content":"### 都是缓存惹的祸\n\n在项目开发中，我们的数据都是要持久化到磁盘中去，比如使用 MySQL 进行持久化存储，但是呢由于流量越来越大，查询速度也逐渐变慢了起来，于是我们决定！使用缓存！然而使用缓存导致会经常面临三座大山！缓存穿透！！缓存击穿！！缓存雪崩！！，接下来我们将会逐一分析他们导致的原因以及解决方法。\n\n### 缓存雪崩\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/w33BhuuN-image.png)\n\n\n#### 介绍\n\n缓存雪崩是指在某个时间点，大量缓存同时失效或被清空，导致大量请求直接打到数据库或后端系统，造成系统负载激增，甚至引发系统崩溃。这通常是由于缓存中的大量数据在同一时间失效引起的。想象一个在线电商系统，用户访问频繁，需要频繁查询商品信息。假设某一系列的商品突然全部同一时间失效，那就会造成我们的缓存雪崩。或者某一个时刻 Redis 缓存中间件故障了，导致服务全部打到了数据库，也会导致缓存雪崩的情况。\n\n#### 解决办法\n\n缓存键同时失效：\n\n1）过期时间随机化：设置缓存的过期时间，加上一个随机值，避免同一时间大量缓存失效。\n\n2）使用多级缓存：引入多级缓存机制，如本地缓存和分布式缓存相结合，减少单点故障风险。\n\n3）缓存预热：系统启动时提前加载缓存数据，避免大量请求落到冷启动状态下的数据库。\n\n4）加互斥锁：保证同一时间只有一个请求来构建缓存，别的只能等它构建完成再从缓存中读取。\n\n缓存中间件故障：\n\n1）服务熔断：暂停业务的返回数据，直接返回错误。\n\n2）构建集群：构建多个 Redis 集群保证其高可用。\n\n### 缓存击穿\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/jVeGv0EU-image.png)\n\n#### 介绍\n\n缓存击穿是指针对某一热点数据的大量请求导致缓存失效，进而直接请求数据库，增加数据库负载。这种情况通常发生在某个特定的缓存 key 在失效时，恰好有大量请求到达。想象一下大家都在抢茅台，但在某一时刻茅台的缓存失效了，大家的请求打到了数据库中，这就是缓存击穿，那他跟缓存雪崩有什么区别呢？缓存雪崩是多个 key 同时，缓存击穿是某个热点 key 崩溃。也可以认为缓存击穿是缓存雪崩的子集。\n\n#### 解决办法\n\n1）加互斥锁：保证同一时间只有一个请求来构建缓存，别的只能等它构建完成再从缓存中读取。跟缓存雪崩相同。\n\n2）永久：不要给热点数据设置过期时间。\n\n### 缓存穿透\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/Cvb431wR-image.png)\n\n\n#### 介绍\n\n缓存穿透是指查询一个不存在的数据，由于缓存和数据库中均不存在，导致每次请求都直接访问数据库，增加数据库负载。攻击者可以通过构造不存在的 key 发起大量请求，造成系统宕机。比如有些小黑子对于我们开发的网站进行恶意的请求，将一些数据库不存在的 ID 疯狂的打在我们的服务器上，如果没做好缓存穿透的预防，还真给你们小黑子得逞了。\n\n#### 解决办法\n\n1）防止非法请求：检查非法请求，封禁其 IP 以及账号，防止它再次为非作歹。。\n\n2）缓存空值：允许缓存空值或者可以给他一个默认值。\n\n3）使用布隆过滤器：通过布隆过滤器给数据做一个标记，当发生缓存穿透时也不会请求数据库造成压力，直接通过布隆过滤器和 Redis 判断返回。","category":"文章","cover":null,"language":null,"externalLink":null,"shortLink":null,"componentName":null,"viewNum":14,"thumbNum":0,"favourNum":0,"commentNum":0,"priority":0,"userId":"1612254411675926529","reviewStatus":1,"reviewMessage":null,"reviewerId":null,"reviewTime":null,"createTime":"2024-04-18 13:58:01","updateTime":"2024-04-19 20:28:54","user":{"id":"1612254411675926529","planetCode":"12852","userName":"聪ζ","userAvatar":"https://pic.code-nav.cn/user_avatar/1612254411675926529/JbN5T832-1.jpg","gender":null,"userProfile":null,"userRole":"vip","interests":[],"place":null,"birthday":null,"school":null,"major":null,"education":"本科","graduationYear":2023,"jobStatus":"已工作","company":null,"job":"后端","workYear":null,"direction":"后端","goal":null,"github":null,"blog":null,"score":0,"coin":0,"followeeNum":2,"followNum":0,"followStatus":null,"vipExpireTime":"2024-08-21 21:17:54","lastLoginTime":null,"createTime":"2023-01-09 09:06:20","updateTime":"2024-04-19 13:24:18"},"tags":["文章"],"fileList":null,"videoList":null,"atUserList":null,"pictureList":null,"hasThumb":false,"hasFavour":false,"needVip":null,"atUserVOList":null},{"id":"1780812347909152769","title":"IDEA 同时关联 GitHub 和 Gitee 远程仓库","description":"IDEA 同时关联 GitHub 和 Gitee 远程仓库","content":"\n一. 前言\n\n各位选择代码托管可能选择 GitHub 或者 Gitee，推送也可能 push 其中一个，有没有想过如何同时 push到 GitHub 和 Gitee \n以我的 sql-slow-mirror 项目为例子，我使用小号作为演示。\n工具：IDEA\n\n二. GitHub 准备工作\n\n新建仓库\n\n1）在 GitHub 上面新建空白项目\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/O6xZplUk-image.png)\n\n2）新建空白项目之后得到一条.git的仓库地址，记录下来后续有用\n\n仓库地址举例：https://github.com/xxxx/sql-slow-mirror.git\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/EVd7SKTS-image.png)\n\n\n三. Gitee 准备工作\n\n新建仓库\n\n\n1）和 GitHub 操作同理，新建空白项目：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/xbAYG50n-image.png)\n\n2）新建空白项目之后得到一条 .git 的链接，记录下来后续有用\n\n仓库地址举例：https://gitee.com/xxx/sql-slow-mirror.git\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/JP3aPSZ0-image.png)\n\n四. idea 配置远程仓库地址\n\n\n为了演示效果，将 .idea 文件夹删除\n\n建立本地 git本地代码仓库\n\n相信各位新建项目，想推送到远程代码仓库都是这样的：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/TncjHIq0-image.png)\n\n点击 create Git repository，就能将代码托管到本地\n\n\n配置远程代码仓库地址\n\n1）本地git\n\n此时可以找到git->GitHub->share project on GitHub 可以推送到 GitHub，即可退出\n\n此操作就不需要在GitHub上创建新仓库\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/HNrG6JxH-image.png)\n\n以上操作可以通过 idea 简单地完成单一远程代码仓库 GitHub 托管，如果我想每次更新都能推送 GitHub 和 Gitee 甚至 GitLab 或其他呢？就可以点击 Manage Remotes：\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/7szcYsTA-image.png)\n\n\n2）连接远程地址\n\n此时，上文所提及到的远程地址就有用处了\n需要填写 Name 和 URL，NAME 就填写一个，个人习惯是按照仓库不同填写 Gitee 和 Github:\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/DVngMzUg-image.png)\n\n\n填写 Gitee 和 GitHub之后如下：\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/Xxtna0BJ-image.png)\n\n\n\n3）愉快的代码提交\n\n接下来我们进行代码修改需要推送，git push操作就可以推送到我们想要推送的远程代码仓库中了：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/Cv2VVNC2-image.png)\n\n\n就可以分别推送到 GitHub 和 Gitee：﻿﻿\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/V1bw8XQB-image.png)\n\n\n4）推送成功\n\n点击 Psuh 成功后就能在自己的仓库页面看到更新内容啦：\n\n![image.png](https://pic.code-nav.cn/post_picture/1612254411675926529/q6MnUiX3-image.png)\n\n","category":"文章","cover":null,"language":null,"externalLink":null,"shortLink":null,"componentName":null,"viewNum":10,"thumbNum":0,"favourNum":0,"commentNum":0,"priority":0,"userId":"1612254411675926529","reviewStatus":1,"reviewMessage":null,"reviewerId":null,"reviewTime":null,"createTime":"2024-04-18 12:15:24","updateTime":"2024-04-19 15:53:10","user":{"id":"1612254411675926529","planetCode":"12852","userName":"聪ζ","userAvatar":"https://pic.code-nav.cn/user_avatar/1612254411675926529/JbN5T832-1.jpg","gender":null,"userProfile":null,"userRole":"vip","interests":[],"place":null,"birthday":null,"school":null,"major":null,"education":"本科","graduationYear":2023,"jobStatus":"已工作","company":null,"job":"后端","workYear":null,"direction":"后端","goal":null,"github":null,"blog":null,"score":0,"coin":0,"followeeNum":2,"followNum":0,"followStatus":null,"vipExpireTime":"2024-08-21 21:17:54","lastLoginTime":null,"createTime":"2023-01-09 09:06:20","updateTime":"2024-04-19 13:24:18"},"tags":["文章"],"fileList":null,"videoList":null,"atUserList":null,"pictureList":null,"hasThumb":false,"hasFavour":false,"needVip":null,"atUserVOList":null},{"id":"1780560537051013121","title":"测试视频功能","description":" ","content":"你觉得体验好吗？\n\n环境评论区交流！","category":"文章","cover":null,"language":null,"externalLink":null,"shortLink":null,"componentName":null,"viewNum":40,"thumbNum":4,"favourNum":0,"commentNum":7,"priority":0,"userId":"1619930914211520514","reviewStatus":1,"reviewMessage":"发发发","reviewerId":"1619930914211520514","reviewTime":"2024-04-17 22:12:37","createTime":"2024-04-17 19:34:47","updateTime":"2024-04-19 20:29:34","user":{"id":"1619930914211520514","planetCode":"1012","userName":"SnailRun","userAvatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132","gender":null,"userProfile":null,"userRole":"admin","interests":[],"place":null,"birthday":null,"school":null,"major":null,"education":null,"graduationYear":null,"jobStatus":null,"company":null,"job":null,"workYear":null,"direction":null,"goal":null,"github":"https://github.com/chaseFunny","blog":"https://chasefunny.github.io/","score":40,"coin":0,"followeeNum":21,"followNum":3,"followStatus":null,"vipExpireTime":"2024-04-13 22:37:59","lastLoginTime":null,"createTime":"2023-01-30 13:30:01","updateTime":"2024-04-18 16:42:37"},"tags":["文章","算法"],"fileList":null,"videoList":[{"title":"示例","fileId":"1397757889030998129"}],"atUserList":null,"pictureList":null,"hasThumb":false,"hasFavour":false,"needVip":null,"atUserVOList":null},{"id":"1780220807692230657","title":"月薪 3 K，要不要入职？","description":null,"content":"今天看到一个鱼友提问， 24 届只拿到一份月薪 3K 的 Java 岗，是否入职？还是回老家找一份工作？\n\n### 身边真实案例\n\n1）毕业之后做了三个月销售，而后转行来到上海第一份工作 6K，每月倒贴生活费 1K：https://t.zsxq.com/19WN0Qgg8\n\n2）表弟毕业两年，来到上海转行入职（目前持续学习中）：https://t.zsxq.com/190Okl2An\n\n3）毕业在家自学半年，终于入职了：https://t.zsxq.com/19mU8SCbV ，https://t.zsxq.com/19mQZZPeC\n\n4）以及其他鱼友的上岸经历：https://wx.zsxq.com/dweb2/index/tags/%E6%98%9F%E7%90%83%E4%B8%8A%E5%B2%B8/48888851441258\n\n### 你想要什么？\n\n回复这个鱼友问题前，先问鱼友一个问题，你自己想要的是什么？\n\n1）更安逸的生活，回老家，找一份薪资不高但轻松的工作\n\n2）想再努力试试，去大城市再看看，获得更好的发展、薪资和平台\n\n如果你的诉求就是趋向安逸，并且在父母的帮扶下也能在老家过得还不错，这对于你来说的确是个不错的选择，并不是每个人都目标远大，要过 XX 的生活，平淡安逸也是一种幸福。\n\n如果你希望有高的薪资，好的发展机会，还是想去大城市再努力试试，也是不错的选择。但是你既然选择了这个方向，就需要付出相应的努力，而不是仅仅停留在思想上：\n\n1）可以选择厚积薄发，再继续学习技术和做项目提升，而后持续优化简历去投递，争取拿到更好的 Offer 再入职\n\n2）如果短期来看实在提升有限，也可选择入职，但你的目的不是为了 3K 的月薪，而是为了获得入行的机会，争取这一年能补齐技术能力，并且获得实际开发的经验，入职第二年跳槽薪资回归市场平均值。这一年是为大学没有学习而买单，毕业之后加倍补回来。\n\n痛苦是一个好东西，目前求职时遇到的痛苦，都会是后续努力、学习的动力来源，因为你不会想再经历求职一次次被拒的。再一次的希望还在校的鱼友们可以抓紧时间学习，因为淋过雨摔过跤，所以希望鱼友们能尽早确认自己的职业方向，少走一点弯路。那么言归正传，接下来分享我的求职经历。\n\n所以想清楚你想要什么，而后为之努力即可，杜绝既要还要，也不要给自己受限，我技术不行，这些都不是问题。只要你想要，像渴望呼吸一样想要达到，你就一定行。","category":"文章","cover":"https://pic.code-nav.cn/post_cover/1608440217629360130/vXT6DJUn-cb500d91f6b10321b1b251b2574806fc.jpeg","language":null,"externalLink":null,"shortLink":null,"componentName":null,"viewNum":42,"thumbNum":3,"favourNum":1,"commentNum":0,"priority":0,"userId":"1608440217629360130","reviewStatus":1,"reviewMessage":null,"reviewerId":null,"reviewTime":null,"createTime":"2024-04-16 21:04:50","updateTime":"2024-04-19 18:02:21","user":{"id":"1608440217629360130","planetCode":"1285","userName":"小y","userAvatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKhOqyiahbWybPMINia0hJbTDoZbs1ACTb9ldJS99dIE3ckBSjT3z7icVJzXol7BpFoyibESEWqYFagXg/132","gender":null,"userProfile":null,"userRole":"admin","interests":[],"place":null,"birthday":null,"school":null,"major":null,"education":null,"graduationYear":null,"jobStatus":null,"company":null,"job":null,"workYear":null,"direction":null,"goal":null,"github":null,"blog":null,"score":40,"coin":0,"followeeNum":12,"followNum":0,"followStatus":null,"vipExpireTime":"2286-11-21 01:46:39","lastLoginTime":null,"createTime":"2022-12-29 20:30:05","updateTime":"2024-04-18 17:19:08"},"tags":["文章","求职"],"fileList":null,"videoList":[],"atUserList":null,"pictureList":null,"hasThumb":false,"hasFavour":false,"needVip":null,"atUserVOList":null},{"id":"1779872775754817537","title":"SpringBoot通过自定义注解实现多数据源","description":"SpringBoot通过自定义注解实现多数据源","content":"# SpringBoot通过自定义注解实现多数据源\n\n## 1.前言☕\n\n大家好，我是Leo哥\uD83E\uDEE3\uD83E\uDEE3\uD83E\uDEE3，今天继续带来一篇关于SpringBoot实现多数据源的实战案例。好了，话不多说让我们开始吧\uD83D\uDE0E\uD83D\uDE0E\uD83D\uDE0E。\n\n\n\n## 2.概述\n\n在实际开发中，我们往往面临一个应用需要访问多个数据库的情况。例如下面两种场景。\n\n- **业务复杂：** 数据分布在不同的数据库，数据库拆了，应用没拆，一个公司有多个子项目，各用各的数据库。\n\n- 读**写分离：** 为了解决数据库的读性能瓶颈（读比写性能更高，写锁会影响读阻塞，从而影响读的性能）\n\n  很多数据库拥有主从架构，也就是说，一台 **主数据库服务器**，是对外提供增删改查业务的生产服务器；\n\n  另一台**从数据库服务器**，主要进行读的操作。\n\n  读写分离：解决高并发下读写受影响。数据更新在主库上进行，主库将数据变更信息同步给从库。在查询时，在从库上进行，从而分担主库的压力。\n\n我们可以在代码层面解决这种动态数据源切换的问题，而不需要使用 **mycat**、**shardingJDBC** 等其他中间件。本文将主要以自定义注解 + 继承 `AbstractRoutingDataSource` 实现读写分离。\n\n\n\n## 3.如何实现多数据源\n\n在 **SpringBoot** 项目中实现读写分离通常需要以下几步：\n\n1. 配置数据源：你需要为读操作和写操作分别配置一个数据源。\n2. 创建数据源路由逻辑：这通常通过扩展 Spring 的 `AbstractRoutingDataSource` 来实现。它允许你根据一定的逻辑来决定使用哪个数据源（读或写）。\n3. 配置事务管理器：这使得你能够在使用不同数据源时保持事务的一致性。\n4. 服务层或DAO层设计：确保在执行读操作时使用读数据源，在执行写操作时使用写数据源。\n5. 自定义切面，在切面中解析 **@DataSource** 注解。当一个方法或者类上面，有 @DataSource 注解的时候，将 @DataSource 注解所标记的数据源列出来存入到 ThreadLocal 中。\n\n注意：这里使用ThreadLocal的原因是为了保证我们的线程安全。\n\n\n\n## 4.案例实现\n\n接下来我们就按照以上步骤进行编码实现。\n\n### 4.1 创建新模块\n\n首先我们创建一个新的模块命名为：**springboot-dynamic-source**\n\n![image-20240102183810902](https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401021838991.png)\n\n\n\n#### 1.导入依赖\n\n~~~xml\n<dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>cn.hutool</groupId>\n            <artifactId>hutool-all</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid-spring-boot-starter</artifactId>\n        </dependency>\n        <!--mybatis plus-->\n        <dependency>\n            <groupId>com.baomidou</groupId>\n            <artifactId>mybatis-plus-boot-starter</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-aop</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n        </dependency>\n    </dependencies>\n~~~\n\n\n\n#### 2.创建yml配置文件\n\n~~~yml\nserver:\n  port: 8007\n\n\nspring:\n  application:\n    name:  dynamic-source\n  jackson:\n    date-format: yyyy-MM-dd HH:mm:ss\n    time-zone: GMT+8\n  datasource:\n    type: com.alibaba.druid.pool.DruidDataSource\n    driverClassName: com.mysql.cj.jdbc.Driver\n    ds:\n      # 主库数据源\n      master:\n        url: jdbc:mysql://localhost:3307/test01?useUnicode=true&characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=true&serverTimezone=GMT%2B8\n        username: root\n        password: root\n      # 从库数据源\n      slave:\n        url: jdbc:mysql://localhost:3307/test02?useUnicode=true&characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=true&serverTimezone=GMT%2B8\n        username: root\n        password: root\n    # 初始连接数\n    initialSize: 5\n    # 最小连接池数量\n    minIdle: 10\n    # 最大连接池数量\n    maxActive: 20\n    # 配置获取连接等待超时的时间\n    maxWait: 60000\n    # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒\n    timeBetweenEvictionRunsMillis: 60000\n    # 配置一个连接在池中最小生存的时间，单位是毫秒\n    minEvictableIdleTimeMillis: 300000\n    # 配置一个连接在池中最大生存的时间，单位是毫秒\n    maxEvictableIdleTimeMillis: 900000\n    # 配置检测连接是否有效\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: false\n    testOnReturn: false\n    webStatFilter:\n      enabled: true\n    statViewServlet:\n      enabled: true\n      # 设置白名单，不填则允许所有访问\n      allow:\n      url-pattern: /druid/*\n      # 控制台管理用户名和密码\n      login-username: admin\n      login-password: 123456\n    filter:\n      stat:\n        enabled: true\n        # 慢SQL记录\n        log-slow-sql: true\n        slow-sql-millis: 1000\n        merge-sql: true\n      wall:\n        config:\n          multi-statement-allow: true\n\n\nlogging:\n  level:\n    org.javatop: debug\n  pattern:\n    dateformat: HH:mm:ss:SSS\n  file:\n    path: \"logs/${spring.application.name}\"\n~~~\n\nds 中是我们的所有数据源。**master** 是默认的数据源，不可修改，其他的数据源可以修改并添加多个。\n\n#### 3.准备数据库\n\n我这里需要提前准备两个数据库，一个是主数据库master，一个是从数据库slave。\n\n我们会后面会通过一个自定义注解去实现动态切换数据库。\n\n这里给出我们创建的一个user表的SQL语句。\n\n~~~sql\nCREATE TABLE `user` (\n  `id` int NOT NULL AUTO_INCREMENT,\n  `username` varchar(50) DEFAULT NULL,\n  `age` int DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=101 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n~~~\n\n\n\n### 4.2 加载数据源\n\n我们可以通过@ConfigurationProperties 注解加载定义的配置文件。spring.datasource 对应的注解都会匹配到。\n\n~~~java\npackage org.javatop.dynamic.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\nimport javax.sql.DataSource;\nimport java.util.Map;\n\n/**\n * @author : Leo\n * @version 1.0\n * @date 2024-01-02 15:10\n * @description :\n */\n@ConfigurationProperties(prefix = \"spring.datasource\")\npublic class DruidProperties {\n    private String type;\n    private String driverClassName;\n    private Map<String, Map<String,String>> ds;\n\n    private Integer initialSize;\n    private Integer minIdle;\n    private Integer maxActive;\n    private Integer maxWait;\n\n    /**\n     *一会在外部构建好一个 DruidDataSource 对象，包含三个核心属性 url、username、password\n     * 在这个方法中设置公共属性\n     * @param druidDataSource\n     * @return\n     */\n    public DataSource dataSource(DruidDataSource druidDataSource){\n        druidDataSource.setInitialSize(initialSize);\n        druidDataSource.setMinIdle(minIdle);\n        druidDataSource.setMaxActive(maxActive);\n        druidDataSource.setMaxWait(maxWait);\n        return druidDataSource;\n    }\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getDriverClassName() {\n        return driverClassName;\n    }\n\n    public void setDriverClassName(String driverClassName) {\n        this.driverClassName = driverClassName;\n    }\n\n    public Map<String, Map<String, String>> getDs() {\n        return ds;\n    }\n\n    public void setDs(Map<String, Map<String, String>> ds) {\n        this.ds = ds;\n    }\n\n    public Integer getInitialSize() {\n        return initialSize;\n    }\n\n    public void setInitialSize(Integer initialSize) {\n        this.initialSize = initialSize;\n    }\n\n    public Integer getMinIdle() {\n        return minIdle;\n    }\n\n    public void setMinIdle(Integer minIdle) {\n        this.minIdle = minIdle;\n    }\n\n    public Integer getMaxActive() {\n        return maxActive;\n    }\n\n    public void setMaxActive(Integer maxActive) {\n        this.maxActive = maxActive;\n    }\n\n    public Integer getMaxWait() {\n        return maxWait;\n    }\n\n    public void setMaxWait(Integer maxWait) {\n        this.maxWait = maxWait;\n    }\n}\n~~~\n\n然后我们开始通过进行加载`DruidProperties`来加载数据源。\n\n\n\n**@EnableConfigurationProperties** :这个注解的意思是使 ConfigurationProperties 注解生效。\n\n~~~java\npackage org.javatop.dynamic.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.stereotype.Component;\n\nimport javax.sql.DataSource;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * @author : Leo\n * @version 1.0\n * @date 2024-01-02 15:12\n * @description : 加载数据源\n */\n\n@Component\n@EnableConfigurationProperties(DruidProperties.class)\npublic class LoadDataSource {\n\n    @Autowired\n    DruidProperties druidProperties;\n\n    public Map<String, DataSource> loadAllDataSource()   {\n        Map<String, DataSource> map =new HashMap<>();\n        Map<String, Map<String, String>> ds = druidProperties.getDs();\n        try {\n            Set<String> keySet = ds.keySet();\n            for (String key : keySet) {\n                map.put(key, druidProperties.dataSource((DruidDataSource) DruidDataSourceFactory.createDataSource(ds.get(key))));\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return map;\n    }\n}\n~~~\n\n**loadAllDataSource()** 方法可以通过读取application.yml配置文件中所有数据源对象。(我们这里有一个master主数据库，和一个slave从数据库)\n\n**druidProperties.dataSource（DruidDataSource druidDataSource）** 这个方法为每个数据源配置其他额外的属性（最大连接池等信息）。\n\n**DruidDataSourceFactory.createDataSource(ds.get(key)**：创建一个数据源，赋予三个核心的属性。（username、url、password）\n\n最终，所有的数据源都会存入map中。\n\n\n\n### 4.3 自定义ThreadLocal工具类\n\n我们这里定义一个简单的ThreadLocal工具类\n\n~~~java\npackage org.javatop.dynamic.utils;\n\n/**\n * @author : Leo\n * @version 1.0\n * @date 2024-01-02 15:13\n * @description : ThreadLocal工具类\n */\npublic class DynamicDataSourceUtil {\n\n    private static final ThreadLocal<String> CONTEXT_HOLDER =new ThreadLocal<>();\n\n    public static void setDataSourceType(String dsType){\n        CONTEXT_HOLDER.set(dsType);\n    }\n    public static String getDataSourceType(){\n        return CONTEXT_HOLDER.get();\n    }\n\n    public static void clear(){\n        CONTEXT_HOLDER.remove();\n    }\n}\n~~~\n\n\n\n### 4.4 自定义注解\n\n首先需要通过一个枚举类来设定一下我们的默认数据源，也是是master主数据库。\n\n~~~java\npackage org.javatop.dynamic.constant;\n\n/**\n * @author : Leo\n * @version 1.0\n * @date 2024-01-02 15:13\n * @description :\n */\npublic interface DataSourceType {\n    String default_ds_name =\"master\";\n}\n~~~\n\n然后自定义一个注解，后面也就是通过这个注解来动态的配置切换我们的数据源，这里就也叫Datasource吧。\n\n~~~java\npackage org.javatop.dynamic.annotation;\n\nimport org.javatop.dynamic.constant.DataSourceType;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * @author : Leo\n * @version 1.0\n * @date 2024-01-02 15:14\n * @description :  这个注解将来可以加在某一个 service 类上或者方法上，通过 value 属性来指定类或者方法应该使用哪个数据源\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface DataSource{\n\n    /**\n     * 如果一个方法上加了 @DataSource 注解，但是却没有指定数据源的名称，那么默认使用 Master 数据源\n     * @return\n     */\n    String value() default DataSourceType.default_ds_name;\n}\n~~~\n\n\n\n\n\n### 4.5 AOP解析自定义注解\n\n~~~java\npackage org.javatop.dynamic.annotation;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.javatop.dynamic.utils.DynamicDataSourceUtil;\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author : Leo\n * @version 1.0\n * @date 2024-01-02 15:15\n * @description : AOP解析自定义注解\n */\n@Component\n@Aspect\npublic class DataSourceAspect {\n\n\n    /**\n     * @annotation(org.javatop.dynamic.annotation.DataSource) 表示方法上有 @DataSource 注解 就将方法拦截下来。\n     * @within :如果类上面有 @DataSource 注解，就将类中的方法拦截下来。\n     */\n    @Pointcut(\"@annotation(org.javatop.dynamic.annotation.DataSource) || \" +\n            \"@within(org.javatop.dynamic.annotation.DataSource)\")\n    public void pc(){\n\n    }\n\n    @Around(\"pc()\")\n    public Object around(ProceedingJoinPoint point){\n        //获取方法上面的注解\n        DataSource dataSource =getDataSource(point);\n        if(dataSource!=null){\n            // 注解中数据源的名称\n            String value = dataSource.value();\n            DynamicDataSourceUtil.setDataSourceType(value);\n        }\n        try {\n            return point.proceed();\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n        }finally {\n            DynamicDataSourceUtil.clear();\n        }\n        return null;\n    }\n\n    private DataSource getDataSource(ProceedingJoinPoint point) {\n        /**\n         * 先去查找方法上的注解，如果没有，再去类中找。\n         */\n        MethodSignature signature = (MethodSignature)point.getSignature();\n        DataSource annotation = AnnotationUtils.findAnnotation(signature.getMethod(), DataSource.class);\n        if(annotation!=null){\n            return annotation;\n        }\n        return AnnotationUtils.findAnnotation(signature.getDeclaringType(),DataSource.class);\n    }\n}\n~~~\n\n\n\n#### @Pointcut 定义\n\n```java\n@Pointcut(\"@annotation(org.javatop.dynamic.annotation.DataSource) || \" +\n          \"@within(org.javatop.dynamic.annotation.DataSource)\")\npublic void pc() {\n\n}\n```\n\n- `@Pointcut` 是一个定义在方法上的注解，用来指定一个切点（即在何处进行拦截）。\n- `\"@annotation(org.javatop.dynamic.annotation.DataSource)\"` 表示拦截所有被 `@DataSource` 注解标记的方法。\n- `\"@within(org.javatop.dynamic.annotation.DataSource)\"` 表示拦截所有在类级别被 `@DataSource` 注解标记的类中的方法。\n- `pc()` 方法本身是空的，因为所有的逻辑都将在与这个切点相关的通知（advice）中定义。\n\n#### @Around 通知\n\n```java\ne@Around(\"pc()\")\npublic Object around(ProceedingJoinPoint point) {\n    DataSource dataSource = getDataSource(point);\n    if (dataSource != null) {\n        String value = dataSource.value();\n        DynamicDataSourceUtil.setDataSourceType(value);\n    }\n    try {\n        return point.proceed();\n    } catch (Throwable throwable) {\n        throwable.printStackTrace();\n    } finally {\n        DynamicDataSourceUtil.clear();\n    }\n    return null;\n}\n```\n\n- `@Around(\"pc()\")` 表示这是一个环绕通知，它会在 `pc()` 方法所定义的切点前后执行。\n- `ProceedingJoinPoint point` 是连接点的信息，它包含了方法的所有相关信息，如方法名、参数等。\n- `getDataSource(point)` 用来获取方法或类上的 `@DataSource` 注解。\n- 如果存在 `@DataSource` 注解，它会从注解中获取数据源的名称，并通过 `DynamicDataSourceUtil.setDataSourceType(value)` 设置当前线程的数据源。\n- `point.proceed()` 是调用原始方法的地方。\n- `finally` 块中的 `DynamicDataSourceUtil.clear()` 用于在方法执行完毕后清理数据源设置，确保不会影响其他的数据库操作。\n\n**最后获取@DataSource注解**\n\n\n\n### 4.6 自定义动态数据源\n\n~~~java\npackage org.javatop.dynamic.config;\n\nimport org.javatop.dynamic.constant.DataSourceType;\nimport org.javatop.dynamic.utils.DynamicDataSourceUtil;\nimport org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\nimport org.springframework.stereotype.Component;\n\nimport javax.sql.DataSource;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author : Leo\n * @version 1.0\n * @date 2024-01-02 15:18\n * @description : 定义动态数据源\n */\n@Component\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n    public DynamicDataSource(LoadDataSource loadDataSource) {\n        // 1、设置所有的数据源\n        Map<String, DataSource> stringDataSourceMap = loadDataSource.loadAllDataSource();\n        super.setTargetDataSources(new HashMap<>(stringDataSourceMap));\n        // 2、设置默认的数据源\n        super.setDefaultTargetDataSource(stringDataSourceMap.get(DataSourceType.default_ds_name));\n\n        super.afterPropertiesSet();\n    }\n\n    /**\n     * 这个方法用来返回数据源名称，当系统需要获取数据源的时候，会自动调用该方法获取数据源的名称\n     * @return\n     */\n    @Override\n    protected Object determineCurrentLookupKey() {\n        return DynamicDataSourceUtil.getDataSourceType();\n    }\n}\n~~~\n\n1. `DynamicDataSource` 类扩展自 `AbstractRoutingDataSource` 类，这是Spring框架提供的一个抽象类，用于实现数据源的动态路由。\n2. 构造函数 `public DynamicDataSource(LoadDataSource loadDataSource)` 接收一个 `LoadDataSource` 类型的参数。这个参数被用于加载所有的数据源配置。\n   - `Map<String, DataSource> stringDataSourceMap = loadDataSource.loadAllDataSource();` 这行代码调用了 `loadDataSource` 的 `loadAllDataSource` 方法来加载所有数据源配置，并将其存储在一个名为 `stringDataSourceMap` 的Map中，其中键是数据源的名称，值是对应的 `DataSource` 对象。\n   - `super.setTargetDataSources(new HashMap<>(stringDataSourceMap));` 这行代码设置了目标数据源。它将前面加载的所有数据源 `stringDataSourceMap` 设置为目标数据源。\n   - `super.setDefaultTargetDataSource(stringDataSourceMap.get(DataSourceType.default_ds_name));` 这行代码设置了默认的数据源。它通过 `DataSourceType.default_ds_name` 从 `stringDataSourceMap` 中获取默认的数据源，并设置为默认数据源。\n   - `super.afterPropertiesSet();` 是一个初始化方法，确保所有属性都被正确设置。\n3. `determineCurrentLookupKey()` 方法是 `AbstractRoutingDataSource` 的一个抽象方法，必须要实现。这个方法用于决定使用哪个数据源，通常情况下是根据某种条件动态返回数据源名称。\n   - `return DynamicDataSourceUtil.getDataSourceType();` 这行代码返回当前线程所使用的数据源的名称。`DynamicDataSourceUtil` 是一个工具类，可能提供了线程局部变量（ThreadLocal）来存储每个线程所选择的数据源名称。\n\n这样，当应用程序需要与数据库进行交互时，就会通过 `DynamicDataSource` 获取到当前线程所指定的数据源，并进行相应的数据库操作。这种方式能够在不同业务场景中灵活切换数据源，非常适合多租户、读写分离等复杂的数据库应用场景。\n\n\n\n### 4.7 编写业务层\n\n我们编写一个service层\n\n~~~java\npackage org.javatop.dynamic.service;\n\nimport org.javatop.dynamic.annotation.DataSource;\nimport org.javatop.dynamic.domain.User;\nimport org.javatop.dynamic.mapper.UserMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @author : Leo\n * @version 1.0\n * @date 2024-01-02 15:26\n * @description :\n */\n@Service\npublic class UserService{\n    @Autowired\n    private UserMapper userMapper;\n\n    @DataSource(\"slave\")\n//    @DataSource\n    public List<User> getAll(){\n        List<User> all = userMapper.getAll();\n        return all;\n    }\n}\n~~~\n\n我们在getAll()方法上加上@DataSource(\"slave\")，并指定slave从数据库。\n\n然后再编写一个mapper，去操作数据库。\n\n~~~java\npackage org.javatop.dynamic.mapper;\n\nimport org.apache.ibatis.annotations.Mapper;\nimport org.apache.ibatis.annotations.Select;\nimport org.javatop.dynamic.domain.User;\n\nimport java.util.List;\n\n/**\n * @author : Leo\n * @version 1.0\n * @date 2024-01-02 15:26\n * @description :\n */\n@Mapper\npublic interface UserMapper {\n    @Select(\"select * from user\")\n    List<User> getAll();\n}\n~~~\n\n### 4.8 测试\n\n~~~java\npackage org.javatop.dynamic;\n\nimport org.javatop.dynamic.domain.User;\nimport org.javatop.dynamic.service.UserService;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n\nimport java.util.List;\n\n/**\n * @author : Leo\n * @version 1.0\n * @date 2024-01-02 15:32\n * @description :\n */\n@SpringBootTest\npublic class DynamicTest {\n\n    @Autowired\n    private UserService userService;\n\n    /**\n     *  用于测试:\n     */\n    @Test\n    public void test() {\n        List<User> all = userService.getAll();\n        if(all !=null){\n            for (User user : all) {\n                System.out.println(user);\n            }\n        }\n    }\n}\n~~~\n\n我们查看控制台。\n\n![image-20240102193458748](https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401021934820.png)\n\n![image-20240102193553638](https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202401021935677.png)\n\n可以看出来我们去查询的是test02库中的user数据。\n\n大功告成!!!\n\n## 5.总结\uD83C\uDF6D\n\n以上便是本文的全部内容，本人才疏学浅，文章有什么错误的地方，欢迎大佬们批评指正！我是**Leo**，一个在互联网行业的小白，立志成为更好的自己。\n\n如果你想了解更多关于**Leo**，可以关注公众号-程序员Leo，后面文章会首先同步至公众号。\n","category":"文章","cover":null,"language":null,"externalLink":null,"shortLink":null,"componentName":null,"viewNum":25,"thumbNum":4,"favourNum":3,"commentNum":0,"priority":0,"userId":"1768274766864605186","reviewStatus":1,"reviewMessage":null,"reviewerId":null,"reviewTime":null,"createTime":"2024-04-15 22:01:52","updateTime":"2024-04-19 16:14:18","user":{"id":"1768274766864605186","planetCode":"12644","userName":"无名小卒","userAvatar":"https://pic.code-nav.cn/user_avatar/1768274766864605186/qzSxxhhE-Leo.jpg","gender":1,"userProfile":null,"userRole":"vip","interests":["Java"],"place":null,"birthday":null,"school":null,"major":null,"education":null,"graduationYear":1,"jobStatus":"已工作","company":null,"job":"后端","workYear":1,"direction":"后端","goal":"社招","github":null,"blog":null,"score":0,"coin":0,"followeeNum":0,"followNum":4,"followStatus":null,"vipExpireTime":"2025-03-14 21:53:56","lastLoginTime":null,"createTime":"2024-03-14 21:55:32","updateTime":"2024-04-18 21:49:14"},"tags":["文章","Java"],"fileList":null,"videoList":null,"atUserList":null,"pictureList":null,"hasThumb":false,"hasFavour":false,"needVip":null,"atUserVOList":null},{"id":"1779763247138807810","title":"面试官问我，项目是否自己做的？我说。。。","description":null,"content":"编程导航里一位鱼友提问，\"面试官问我，项目是否自己做的\"，我该如何回复？\n\n首先从面试官的视角，为什么要问这个：\n\n1）确认项目的真实性，你是自己写的代码，还是网上直接 Copy 的，或者是干脆编的项目。\n\n2）项目是否有实际的使用，是单纯的练习项目，还是有真实用户使用，并持续运营的项目。\n\n所以我们应该如何回复：\n\n1）不是自己做的，面试直接挂。\n\n2）是自己做的，是练手项目，面试大概率也挂，面试官没有问你项目的欲望。\n\n3）是自己做的，并且从项目的需求背景、需求分享、代码实现、部署上线都能讲得头头是道，甚至推动身边的一些同学用了这个产品，收到一些反馈并且做了系统优化，大大的加分！\n\n所以，你只要是跟着编程导航敲了代码并且实现项目（建议上线），并且看了完整的视频教程熟悉项目开发的全流程，甚至做了一些功能拓展，那么完全可以说是自己做的（而且本来也是自己做的）。","category":"文章","cover":"https://pic.code-nav.cn/post_cover/1608440217629360130/OLsUPDKk-0329.png","language":null,"externalLink":null,"shortLink":null,"componentName":null,"viewNum":55,"thumbNum":1,"favourNum":0,"commentNum":0,"priority":0,"userId":"1608440217629360130","reviewStatus":1,"reviewMessage":null,"reviewerId":null,"reviewTime":null,"createTime":"2024-04-15 14:46:39","updateTime":"2024-04-19 20:30:00","user":{"id":"1608440217629360130","planetCode":"1285","userName":"小y","userAvatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKhOqyiahbWybPMINia0hJbTDoZbs1ACTb9ldJS99dIE3ckBSjT3z7icVJzXol7BpFoyibESEWqYFagXg/132","gender":null,"userProfile":null,"userRole":"admin","interests":[],"place":null,"birthday":null,"school":null,"major":null,"education":null,"graduationYear":null,"jobStatus":null,"company":null,"job":null,"workYear":null,"direction":null,"goal":null,"github":null,"blog":null,"score":40,"coin":0,"followeeNum":12,"followNum":0,"followStatus":null,"vipExpireTime":"2286-11-21 01:46:39","lastLoginTime":null,"createTime":"2022-12-29 20:30:05","updateTime":"2024-04-18 17:19:08"},"tags":["文章","求职","面试"],"fileList":null,"videoList":[],"atUserList":null,"pictureList":null,"hasThumb":false,"hasFavour":false,"needVip":null,"atUserVOList":null},{"id":"1779700778454294529","title":"Groovy 学习","description":"Groovy 是一种运行在 Java 虚拟机（JVM）上的动态语言，它以其简洁的语法和强大的功能而受到开发者的青睐。作为一种能够与 Java 无缝交互的语言，Groovy 继承了 Java 的许多优点","content":"# **1、 简介**\n\nGroovy 是一种运行在 Java 虚拟机（JVM）上的动态语言，它以其简洁的语法和强大的功能而受到开发者的青睐。作为一种能够与 Java 无缝交互的语言，Groovy 继承了 Java 的许多优点，并且在某些方面进行了扩展和改进，使得开发者能够更加高效地编写代码。\n\n以下是对Groovy特点的优化概述：\n\n1. **简洁性**：Groovy 的设计哲学之一是减少模板化的代码和重复的模式，使得代码更加简洁。与 Java 相比，完成相同功能的 Groovy 代码通常更短，这使得代码更容易编写和维护。\n2. **动态类型**：Groovy 支持动态类型，这意味着开发者无需显式声明变量类型。这种灵活性使得代码更加简洁，并且能够在编写代码时提供更快的反馈。\n3. **闭包和元编程**：Groovy 引入了闭包和元编程的概念，这些特性使得代码更加灵活和强大。闭包允许开发者编写可重用的代码块，而元编程则允许在运行时动态地创建和修改类和方法。\n4. **函数式编程支持**：Groovy 支持函数式编程范式，开发者可以编写更加简洁和表达性强的代码。在 Groovy 中，不需要显式的 main 函数，这使得编写脚本和快速原型开发变得更加容易。\n5. **默认导入包**：Groovy 默认导入了许多常用的 Java 包，这减少了开发者在编写代码时需要导入的包的数量，进一步简化了代码编写过程。\n6. **公共作用域**：在 Groovy 中，所有的类成员默认是公开的（public），这简化了访问控制的声明，同时也鼓励开发者采用更加开放的设计模式。\n7. **对象化基本类型**：Groovy 将基本类型视为对象，这意味着可以直接在基本类型上调用方法。这种特性使得代码更加一致，并且能够利用对象的特性。\n8. **DSL** **支持**：Groovy 支持领域特定语言（DSL），这使得开发者能够创建和使用专门针对特定问题的简洁、易读的语法。DSL 可以显著提高代码的可读性和可维护性。\n\n> Groovy 是基于 Java 语言的，所以完全兼容 Java 语法,所以对于 java 程序员学习成本较低。\n\n详细了解请参考: https://www.groovy-lang.org/documentation.html\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102751-17.png)\n\n# **2、安装[非必须]**\n\n下载地址: https://groovy.apache.org/download.html\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102747-1.png)\n\n我这里就直接下载整个 4.0.20 版本的了。\n\n然后我们直接找个地方解压,并配置相关的环境变量就好了。\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102748-2.png)\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102748-3.png)\n\n然后就可以使用 CMD 查询是否配置成功了。\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102748-4.png)\n\n# **3、创建项目**\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102748-5.png)\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102748-6.png)\n\n# **4、基本语法**\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102748-7.png)\n\n在Groovy中，类型转换是一个非常自然和灵活的过程，它允许不同类型的数据在需要时自动转换。这种特性极大地简化了代码的编写和维护，因为它减少了显式类型转换的需求。以下是对Groovy中类型转换和类处理的详细说明：\n\n> **类型转换**\n>\n> Groovy支持多种类型之间的自动转换，这包括：\n>\n> 1. **字符串与基本类型之间的转换**：Groovy允许将字符串转换为基本类型（如int、double等），反之亦然。例如，字符串\"123\"可以通过调用`.toInteger()`方法转换为整数。\n> 2. **基本类型与其包装类之间的转换**：Groovy中的基本类型和它们的包装类（如Integer对应int）之间可以无缝转换。这意味着你可以在需要对象的地方使用基本类型，而在需要基本类型的地方使用包装类对象。\n>\n> 这种自动类型转换的特性使得Groovy在处理不同类型的数据时更加灵活和方便。开发者不需要编写额外的代码来进行显式的类型转换，从而可以专注于业务逻辑的实现。\n>\n> **类说明**\n>\n> 在Groovy中，如果你创建了一个没有类定义的脚本文件，这个文件将被当作一个脚本（script）来处理。Groovy会自动将这个脚本转换为一个名为`Script`的类的实例，这个类的名字通常由文件名决定（去掉扩展名.goovy）。\n>\n> 在这个自动生成的`Script`类中，Groovy会创建一个`run`方法，这个方法包含了脚本的所有内容。这样，当你运行这个脚本时，实际上就是在调用这个`run`方法。\n>\n> 此外，为了便于外部执行，Groovy还会在这个自动生成的类中添加一个`main`方法。这个`main`方法会调用`run`方法，使得脚本可以在命令行或其他环境中作为程序执行。\n>\n> 这种将脚本转换为类的做法，使得Groovy脚本既可以作为独立的脚本运行，也可以作为类的一部分被导入和重用。这增加了Groovy的灵活性，并为开发者提供了更多的选择来组织和使用他们的代码。\n\n## **4.1 案例 1:  创建**\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102748-8.png)\n\n## **4.2 案例 2:基本注意点**\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102748-9.png)\n\n提示:方法调用时,在不含有歧义的地方可以省略方法调用时的括号。这类似于使用${变量名}时，括号在不引起歧义的地方可以省略是一样的：如\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102748-10.png)\n\n## **4.3 案例3:引号说明**\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102748-11.png)\n\n## **4.4 案例 4:三个语句结构**\n\nGroovy 支持顺序结构从上向下依次解析、分支结构(if..else、if..else if ..else..、switch..case、for、while、do..while)\n\n具体参考官网：http://www.groovy-lang.org/semantics.html#_conditional_structures\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102748-12.png)\n\n## **4.5 案例 5:类型及权限修饰符**\n\n**Groovy** **中的类型有**: \n\n1.原生数据类型及包装类\n\n| Primitive type | Wrapper class |\n| -------------- | ------------- |\n| boolean        | Boolean       |\n| char           | Character     |\n| short          | Short         |\n| int            | Integer       |\n| long           | Long          |\n| float          | Float         |\n| double         | Double        |\n\n2.类、内部类、抽象类、接口\n\n3.注解\n\n4.Trait: 可以看成是带有方法实现的接口\n\n**权限修饰符**: public、protected、private \n\n> Groovy 类与 Java 类在设计和使用上有一些显著的区别，这些区别使得Groovy在某些方面更加灵活和简洁。以下是Groovy类与Java类之间的主要区别的进一步阐释：\n>\n> 1. **可见性修饰符**：在Java中，你需要使用`public`、`protected`、`private`或`default`关键字来指定类或方法的可见性。而在Groovy中，如果没有明确指定可见性修饰符，类或方法默认是公共的（public）。这减少了模板化的代码，使得代码更加简洁。对于包级别的私有可见性，可以通过`@PackageScope`注解来实现。\n> 2. **属性和getter/setter**：在Java中，你需要为类中的每个字段显式编写getter和setter方法，除非你使用了自动getter和setter的语法（Java 11及以上版本）。而在Groovy中，如果没有为字段指定可见性修饰符，字段将自动转换为属性，并且Groovy会自动生成相应的getter和setter方法。这进一步简化了代码，使得开发者可以专注于业务逻辑的实现。\n> 3. **final属性**：在Groovy中，如果你声明了一个属性为`final`，Groovy不会为这个属性生成setter方法。这是因为`final`关键字表示该属性的值一旦被赋值后就不可更改，因此不需要setter方法。这与Java的行为是一致的，但在Groovy中，你不需要显式编写setter方法。\n> 4. **源文件与类的关系**：在Java中，每个源文件通常只包含一个公共类，并且源文件的名称必须与公共类的名称相匹配。而在Groovy中，一个源文件可以包含一个或多个类，但如果源文件中没有类定义的代码，则将其视为脚本。脚本是一种特殊的类，它们的名称与源文件名相同，并且脚本中定义的所有代码都被包含在`run`方法中。如果你在脚本文件中定义了与文件名相同的类，那么这个类将被视为脚本的扩展，并且可以通过`Script`类来访问。\n>\n> 这些区别使得Groovy在编写脚本和快速原型开发时更加高效和方便。Groovy的这些特性不仅简化了代码，还提高了开发效率，使得开发者可以更加专注于业务逻辑的实现，而不是被繁琐的语法和模板化代码所困扰。\n\n**提 示** **:** 有 关 Groovy 中 各 种 各 样 的 数 据 类 型 和 权 限 修 饰 符 及 Goovy 与 Java 区 别 请 参 考 ：\n\nhttp://www.groovy-lang.org/objectorientation.html#_modifiers_on_a_property\n\n## **4.6 案例 6:集合操作**\n\n| 操作             | List            | Map      |\n| ---------------- | --------------- | -------- |\n| 添加元素         | add()           | put()    |\n| 添加集合         | plus()          |          |\n| 删除指定下标元素 | remove()        |          |\n| 删除指定元素     | removeElement() | remove() |\n| 移除集合中的元素 | removeAll()     |          |\n| 弹出最后一个元素 | pop()           |          |\n| 修改指定下标元素 | putAt()         |          |\n| 遍历             | each()          | each()   |\n| 获取元素个数     | size()          |          |\n| 判断是否包含值   | contains()      |          |\n| 集合加减操作     | 不支持          | +、-     |\n\n> 请参考官网:http://www.groovy-lang.org/syntax.html#_number_type_suffixes \n>\n> **提示**:可以把不同的基本类型添加到同一集合中。\n\n## **4.7 案例 7:类导入**\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102748-13.png)\n\nGroovy 语言默认提供的导入\n\n```Groovy\nimport java.lang.*\nimport java.util.*\nimport java.io.*\nimport java.net.*\nimport groovy.lang.*\nimport groovy.util.*\nimport java.math.BigInteger\nimport java.math.BigDecimal\n```\n\n这样做是因为这些包中的类最常用。通过导入这些样板代码减少了。\n\n参考官网地址：http://www.groovy-lang.org/structure.html#_imports\n\n## **4.8 案例 8:异常处理**\n\nGroovy 中的异常处理和 java 中的异常处理是一样的。\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102749-14.png)\n\n参考官网地址： http://www.groovy-lang.org/semantics.html#_try_catch_finally\n\n## **4.9 案例 9:闭包**\n\n闭包是Groovy语言中一个非常强大和灵活的特性，它允许开发者以一种简洁和表达性强的方式来编写代码。闭包的概念源自函数式编程，它提供了一种定义代码块的方式，这个代码块可以被赋值给变量、作为参数传递给方法或者在类中定义为成员。\n\n### **闭包的特性**\n\n1. **开放和匿名**：闭包不需要显式的类型声明或名称，它可以在任何地方被定义，并且可以被赋值给变量或者作为参数传递。这种开放和匿名的特性使得闭包非常灵活和方便。\n2. **接受参数和返回值**：闭包可以定义自己的参数，就像方法一样。同时，闭包也可以有返回值。这使得闭包可以执行复杂的操作，并且可以返回结果。\n3. **引用外部变量**：闭包可以捕获并使用其定义时所在的作用域中的变量。这意味着闭包可以访问定义它的上下文中的局部变量，甚至是在闭包被调用时那些变量可能已经不存在了。\n\n### **闭包的语法**\n\n闭包的基本语法如下：\n\n```Groovy\n { [closureParameters -> ] statements }\n```\n\n- `closureParameters`：这是闭包的参数列表，它是一个逗号分隔的列表，可以包含类型化的或非类型化的参数。如果闭包不接受参数，这部分可以省略。\n- `->`：这个箭头字符用来分隔参数列表和闭包体。\n- `statements`：这是闭包的主体，包含了一系列的Groovy语句，这些语句定义了闭包要执行的操作。\n\n### **闭包的使用**\n\n闭包可以在多种场合使用，例如：\n\n- 作为变量的值：\n\n```Groovy\n // 定义一个闭包myClosure，它接收一个参数it，返回参数的两倍\n def myClosure = { it * 2 }\n \n // 使用闭包myClosure，传入参数5，检查结果是否等于10\n def result = myClosure(5) == 10\n \n // 打印结果\n println(result)\n```\n\n- 作为方法的参数：\n\n```Groovy\n /**\n  * 遍历一个数字列表并打印每个数字。\n  *\n  * @param numbers 一个包含整数的列表。\n  *\n  * 本示例中没有返回值，因为它只是简单地遍历并打印列表中的每个元素。\n  */\n def numbers = [1, 2, 3, 4, 5]\n // 使用each方法遍历numbers列表，对每个元素执行.println操作进行打印\n numbers.each { println it }\n```\n\n- 在类中定义为成员：\n\n```Groovy\n class MyMath {\n     /**\n      * 将输入参数乘以二。\n      *\n      * @param it 输入的数字。\n      * @return 输入数字的两倍。\n      */\n     def multiplyByTwo = { it * 2 }\n }\n \n // 创建一个 MyMath 的实例\n def math = new MyMath()\n \n // 验证 multiplyByTwo 方法是否正确工作\n assert math.multiplyByTwo(5) == 10\n```\n\n闭包的强大之处在于它的简洁性和灵活性，它使得代码更加紧凑，同时提供了丰富的表达能力。在Groovy中，闭包是实现高阶函数、事件处理和异步编程等高级功能的关键工具。\n\n参考：http://www.groovy-lang.org/closures.html\n\n# **5、在 idea 中创建普通 java 工程**\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102749-15.png)\n\n如果你的idea 在创建 项目的时候没有 Advanced Settomgs 来指定本地的GradleL。那就参考下面去指定本地安装的Gradle。\n\n![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/1713156102749-16.png)\n","category":"文章","cover":"https://pic.code-nav.cn/post_cover/1620630456775032833/g1CxxZ8z-retro-groovy-text-vintage-hippie-psychedelic-clipart-free-vector.jpg","language":null,"externalLink":null,"shortLink":null,"componentName":null,"viewNum":12,"thumbNum":2,"favourNum":1,"commentNum":0,"priority":0,"userId":"1620630456775032833","reviewStatus":1,"reviewMessage":null,"reviewerId":null,"reviewTime":null,"createTime":"2024-04-15 10:38:25","updateTime":"2024-04-19 16:29:06","user":{"id":"1620630456775032833","planetCode":"3790","userName":"叫我阿杰好了","userAvatar":"https://pic.code-nav.cn/user_avatar/1620630456775032833/VD8sEpIL-微信图片_20230523085336.jpg","gender":1,"userProfile":"目前技术社交账号，CSDN JAVA领域优秀创作者，阿里云专家博主。\n微信公众号：叫我阿杰好了","userRole":"vip","interests":["资源","Java","GitHub","面试题"],"place":null,"birthday":null,"school":null,"major":null,"education":null,"graduationYear":null,"jobStatus":"已工作","company":null,"job":"后端","workYear":3,"direction":null,"goal":null,"github":null,"blog":"https://blog.csdn.net/weixin_53041251?spm=1000.2115.3001.5343","score":35,"coin":20,"followeeNum":1,"followNum":1,"followStatus":null,"vipExpireTime":"2025-03-12 23:57:24","lastLoginTime":null,"createTime":"2023-02-01 11:49:45","updateTime":"2024-04-15 10:12:45"},"tags":["文章","Java","后端"],"fileList":null,"videoList":[],"atUserList":null,"pictureList":null,"hasThumb":false,"hasFavour":false,"needVip":null,"atUserVOList":null},{"id":"1779685922640568321","title":"Gradle 入门","description":"各位小伙伴大家好，我是阿杰，这篇博客是要来带大家入门新一代项目自动化构建工具 Gradle。\n\n提到项目自动化构建工具，大家首先想到的是maven，那接下来我们就聊一下Gradle与maven之间的一","content":"# 1、介绍\n\n  各位小伙伴大家好，我是阿杰，这篇博客是要来带大家入门新一代项目自动化构建工具 **`Gradle`**。\n\n  提到项目自动化构建工具，大家首先想到的是`maven`，那接下来我们就聊一下`Gradle`与`maven`之间的一个差异。\n\n  首先，同样作为项目自动化构建工具`maven`，侧重于项目jar包的管理，而`Gradle`则侧重于项目的构建。\n\n  其次，在构建性能方面。`Gradle`的构建性能是要远高于`maven`的。尤其是针对大型多项目的构建。\n\n  我们这里还有其他几点学习`Gradle`的原因，比如spring家族框架的支持。如果目前我们想要学好spring家族框架的源码。比如说spring的源码，你会发现在`GitHub`上，它已经由`maven`转交给了`Gradle`进行管理。\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921281-22.png)\n\n  还有一个原因就是公司的需要，目前实际上市面上已经有公司在使用`Gradle`作为构建工具使用了。\n\n  那既然公司需要，所以我们就要学习。\n\n  然后在[技术雷达](https://www.thoughtworks.com/zh-cn/radar)这个网站上，Maven已经被列入暂缓区了\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921276-1.png)\n\n  # **2 、简介**\n\n  Gradle 是一款**先进的构建自动化工具**，由 Google 专为 Java 应用开发而设计。\n\n  它**基于** **JVM**，提供了一种**灵活、可扩展的构建系统**。Gradle 支持**多种第三方仓库**，如 Maven 和 JCenter，便于依赖管理。其最大的特点在于**简化和优化了依赖项的处理**，采用**传递性依赖管理机制**，避免了传统 XML 配置文件的复杂性。\n\n  取而代之的是，Gradle 使用 **Groovy** **或** **Kotlin** **等现代编程语言**编写**简洁的构建脚本**，大幅提高了构建过程的灵活性和效率。\n\n  官网地址：[Gradle Build Tool](https://gradle.org/)\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921276-2.png)\n\n  # **3、常见的项目构建工具**\n\n  - **Ant（2000年推出）**：Apache推出的基于Java的构建工具，通过`build.xml`文件管理项目。\n    - 优点：灵活、速度快（比Gradle和Maven快）。\n    - 缺点：没有强加编码约定和项目目录结构，需要编写复杂的XML文件，对开发人员有挑战。\n  - **Maven****（2004年推出）**：Apache组织推出的，使用`pom.xml`文件管理项目。\n    - 优点：遵循“约定大于配置”原则，使用统一的GAV坐标进行依赖管理，侧重于包管理。\n    - 缺点：项目构建过程较僵化，配置文件编写不够灵活，不方便自定义组件，构建速度慢于Gradle。\n  - **Gradle（2012年推出）**：Google推出的基于Groovy语言的构建工具，集合了Ant和Maven的优点。\n    - 优点：结合了Ant的灵活性和Maven的“约定大于配置”原则，支持多种远程仓库和插件，侧重于大项目构建。\n    - 缺点：学习成本高、资料较少、脚本灵活但版本兼容性较差。\n\n  | 自动化构建工具对比 | Ant             | Maven       | Gradle                 |\n  | ------------------ | --------------- | ----------- | ---------------------- |\n  | 构建性能           | 最高            | 最低        | 居中                   |\n  | 仓库               | 开发者自己处理  | maven仓库   | 支持多种远程仓库       |\n  | 依赖管理           | ivy管理         | GAV坐标管理 | GNV坐标管理            |\n  | 插件支持           | 实现方便        | 实现较难    | 实现方便               |\n  | 遵循特定目录结构   | No              | 遵循        | 同maven                |\n  | 配置文件           | xml文件最为繁琐 | xml文件     | 代码脚本便于写业务逻辑 |\n  | 侧重点             | 小型项目构建    | 项目包管理  | 大型项目构建           |\n  | 目前地位           | 使用较少        | 目前主流    | 未来趋势(spring家族)   |\n\n  **无论哪种项目构建工具，都有自身的优势和劣势，所以选择一款最适合自己的就是最好的。**\n\n  # **4、 安装**\n\n  ## **4.1 安装说明**\n\n  在SpringBoot 3.0.0 官方文档明确指出,目前 SpringBoot 的 Gradle 插件需要 gradle 7.x 版本及以上\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921276-3.png)\n\n  其中 SpringBoot 与 Gradle 存在版本兼容问题，Gradle 与 Idea 也存在兼容问题，那么相应的 idea 版本也要升级,不能太老。\n\n  那我该如何查看我们本地安装的IDEA，它需要的是哪个版本的Gradle 呢？\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921277-4.png)\n\n  这样我们就可以知道我们要安装哪个版本的Gradle 了。\n\n  还有就是Gradle 是依赖Java的，所以我们一定要先安装Java。\n\n  **SpringBoot 具体参考文档:**[Spring Boot Gradle Plugin Reference Guide](https://docs.spring.io/spring-boot/docs/3.0.0/gradle-plugin/reference/htmlsingle/#getting-started)\n\n  ## **4.2 下载并解压**\n\n  下载地址：[格拉德尔 |释放 (gradle.org)](https://gradle.org/releases/)\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921277-5.png)\n\n  解压\n\n  ## **4.3 配置环境变量**\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921277-6.png)\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921277-7.png)\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921277-8.png)\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921277-9.png)\n\n  > **特别注意**：这里我们接着再配置一个`GRADLE_USER_HOME`环境变量\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921277-10.png)\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921277-11.png)\n\n  > **GRALE_USER_HOME** **相当于配置** **Gradle** **本地仓库位置和** **Gradle Wrapper** **缓存目录。**\n\n  ## **4.4 检测是否安装成功**\n\n  **通过**gradle -v**或者** gradle --version检测是否安装成功\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921277-12.png)\n\n   \n\n  # **5、Gradle 项目目录结构**\n\n  Gradle 项目**默认目录结构和 Maven 项目的目录结构一致**,都是基于**约定大于配置**【Convention Over Configuration】。\n\n  ```Plain\n  my-project/\n   |-- build.gradle (或 build.gradle.kts 如果使用 Kotlin DSL)\n    |-- gradle.properties\n   |-- gradlew (Gradle Wrapper 脚本)\n   |-- gradlew.bat (Windows 下的 Gradle Wrapper 脚本)\n   |-- settings.gradle (或 settings.gradle.kts 如果使用 Kotlin DSL)\n   |-- src/\n   |   |-- main/\n   |   |   |-- java/ (Java 源代码)\n   |   |   |-- resources/ (资源文件，如 properties 文件)\n   |   |   |-- webapp/ (对于 Web 应用)\n   |   |       |-- WEB-INF/\n   |   |           |-- web.xml (对于传统的 WAR 包部署的 Web 应用)\n   |   |-- test/\n   |       |-- java/ (Java 测试代码)\n   |       |-- resources/ (测试资源文件)\n   |-- .gitignore (如果使用 Git 进行版本控制)\n   |-- gradle/\n   |   |-- wrapper/\n   |       |-- gradle-wrapper.jar\n   |       |-- gradle-wrapper.properties\n  ```\n\n  这个结构包括以下部分：\n\n  - `build.gradle` (或 `build.gradle.kts`): 这是 Gradle 的构建脚本，定义了项目的构建逻辑。\n  - `gradle.properties`: 用于存储 Gradle 构建时的属性，如 Gradle 版本或其他配置。\n  - `gradlew` 和 `gradlew.bat`: 这是 Gradle Wrapper 的脚本，它允许你在不需要预先安装 Gradle 的情况下构建项目。\n  - `settings.gradle` (或 `settings.gradle.kts`): 当项目包含多个子项目时，这个文件用于配置项目的层次结构。\n  - `src`: 源代码和资源的主目录。\n    - `main`: 主源代码和资源。\n    - `test`: 测试源代码和资源。\n  - `.gitignore`: Git 版本控制系统使用这个文件来忽略不必要的文件或目录。\n  - `gradle/wrapper`: Gradle Wrapper 的目录，包含了执行 Gradle 构建所需的 JAR 文件和属性文件。 请注意，根据项目的不同，可能还会有其他目录和文件，如用于依赖管理的 `lib` 目录，用于文档的 `docs` 目录，或者用于构建输出的 `build` 目录等。此外，使用不同的插件和构建工具（如 Maven 或 Ant）可能会引入其他文件和目录。\n\n  **Tips**: \n\n  > 1. 只有war工程才有webapp目录，对于普通的jar工程并没有webapp目录\n  > 2. gradlew与gradlew.bat执行的指定wrapper版本中的gradle指令,不是本地安装的gradle指令哦。\n\n  # **6、Gradle 创建第一个项目**\n\n  **借助于** **spring** **脚手架创建** **gradle** **第一个项目**：https://start.spring.io/\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921277-13.png)\n\n  如果图中没有你的有的Java版本，例如java8,也可以选择使用阿里云的镜像进行构建：[https://start.aliyun.com](https://start.aliyun.com/)\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921277-14.png)\n\n  下载下来的代码压缩进行解压，然后用idea打开，查看生成的 gradle 项目目录结构如下所示:\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921277-15.png)\n\n  ## **6.1 Gradle 中的常用指令**\n\n  **需要注意的是：**gradle **的指令要在含有** **build.gradle** **的目录执行**。\n\n  | gradle命令           | 作用                      |\n  | -------------------- | ------------------------- |\n  | gradle clean         | 清空build目录             |\n  | gradle classes       | 编译业务代码和配置文件    |\n  | gradle test          | 编译测试代码,生成测试报告 |\n  | gradle build         | 构建项目                  |\n  | gradle build -x test | 跳过测试构建构建          |\n\n  ## **6.2 修改 maven 下载源**\n\n  Gradle 自带的 Maven 源地址是国外的，该 Maven 源在国内的访问速度是很慢的，除非使用了特别的手段。\n\n  一般情况下，建议使用国内的第三方开放的 Maven 源或企业内部自建 Maven 源。\n\n  ### **6.2.1 认识 init.d 文件夹**\n\n  我们可以在 gradle 的 init.d 目录下创建以.gradle 结尾的文件，.gradle 文件可以实现在 build 开始之前执行，所以你可以在这个文件配置一些你想预先加载的操作。\n\n  ### **6.2.2 在 init.d 文件夹创建 init.gradle 文件**\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921277-16.png)\n\n  文件内容:\n\n  ```Plain\n   allprojects {\n       repositories {\n           mavenLocal()\n           maven {\n               name = \"Alibaba\"\n               url = \"https://maven.aliyun.com/repository/public\"\n           }\n           maven {\n               name = \"Bstek\"\n               url = \"https://nexus.bsdn.org/content/groups/public/\"\n           }\n           mavenCentral()\n       }\n   }\n   \n   buildscript {\n       repositories {\n           maven {\n               name = \"Alibaba\"\n               url = \"https://maven.aliyun.com/repository/public\"\n           }\n           maven {\n               name = \"Bstek\"\n               url = \"https://nexus.bsdn.org/content/groups/public/\"\n           }\n           maven {\n               name = \"M2\"\n               url = \"https://plugins.gradle.org/m2/\"\n           }\n       }\n   }\n  ```\n\n  > 拓展1：启用 `init.gradle` 文件的方法有：\n  >\n  > 1. 在命令行指定文件，例如：\n  > 2.  gradle -I /path/to/some/init.gradle -q taskName\n  > 3. 你可以多次输入此命令来指定多个 `init` 文件。\n  > 4. 把 `init.gradle` 文件放到 `USER_HOME/.gradle/` 目录下。\n  > 5. 把以 `.gradle` 结尾的文件放到 `USER_HOME/.gradle/init.d/` 目录下。\n  > 6. 把以 `.gradle` 结尾的文件放到 `GRADLE_HOME/init.d/` 目录下。 如果存在上面的4种方式的2种以上，Gradle 会按上面的1-4序号依次执行这些文件。如果给定目录下存在多个 `init` 脚本，会按拼音 `a-z` 顺序执行这些脚本。每个 `init` 脚本都存在一个对应的 Gradle 实例，你在这个文件中调用的所有方法和属性，都会委托给这个 Gradle 实例，每个 `init` 脚本都实现了 `Script` 接口。\n  >\n  > \n  >\n  > 拓展2：仓库地址说明\n  >\n  > - `mavenLocal()`：需要配置maven环境变量，指定使用 Maven 本地仓库。本地仓库在配置 Maven 时 `settings.xml` 文件指定的仓库位置，例如 `E:/repository`。Gradle 查找 jar 包顺序如下：\n  >   - `USER_HOME/.m2/settings.xml`\n  >   - `M2_HOME/conf/settings.xml`\n  >   - `USER_HOME/.m2/repository`\n  > - `maven{url地址}`：指定 Maven 仓库；一般用私有仓库地址或其它的第三方库（比如阿里镜像仓库地址）。\n  > - `mavenCentral()`：这是 Maven 的中央仓库。无需配置，直接声明就可以使用。\n  > - `jcenter()`：JCenter 中央仓库。实际也是用的 Maven 搭建的，但相比 Maven 仓库更友好，通过 CDN 分发，并且支持 HTTPS 访问。在新版本中已经废弃了，替换为了 `mavenCentral()`。 总之，Gradle 可以通过指定仓库地址为本地 Maven 仓库地址和远程仓库地址相结合的方式，避免每次都会去远程仓库下载依赖库。这种方式也有一定的问题，如果本地 Maven 仓库有这个依赖，就会从直接加载本地依赖；如果本地仓库没有该依赖，那么还是会从远程下载。但是下载的 jar 不是存储在本地 Maven 仓库中，而是放在自己的缓存目录中，默认在 `USER_HOME/.gradle/caches` 目录。当然如果我们配置过 `GRADLE_USER_HOME` 环境变量，则会放在 `GRADLE_USER_HOME/caches` 目录。那么可不可以将 Gradle caches 指向 Maven repository？我们说这是不行的，因为 caches 下载文件不是按照 Maven 仓库中存放的方式。\n  >\n  > \n  >\n  > 拓展3：阿里云仓库地址请参考：[阿里云 Maven 服务](https://developer.aliyun.com/mvn/guide)。\n\n  ## **6.3 Wrapper 包装器**\n\n  Gradle Wrapper 是对 Gradle 的一层封装，旨在解决不同项目可能需要不同版本的 Gradle 的问题。这在代码共享的场景中尤其有用，例如：\n\n  1. **对方电脑未安装 Gradle**：如果没有 Gradle Wrapper，接收方需要先安装相应版本的 Gradle 才能构建项目。\n  2. **对方电脑安装的 Gradle 版本过旧**：即使安装了 Gradle，版本不匹配也会导致构建失败。\n\n  这时候，我们就可以考虑使用 `Gradle Wrapper` 了。这也是官方建议使用 `Gradle Wrapper` 的原因。实际上有了 `Gradle Wrapper` 之后，我们本地是可以不配置 `Gradle` 的,下载 `Gradle` 项目后，使用 `gradle` 项目自带的 wrapper 操作也是可以的。\n\n  那如何使用 Gradle Wrapper 呢？\n\n  项目中的gradlew、gradlew.cmd脚本用的就是wrapper中规定的gradle版本。参见源码\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921278-17.png)\n\n  使用 Gradle Wrapper 的方式与直接使用 Gradle 命令基本相同，只需将 `gradle` 命令替换为 `gradlew`（或 `gradlew.bat` 在 Windows 系统中）。\n\n  例如，如果原本使用 `gradle build` 来构建项目，使用 Gradle Wrapper 后，应使用 `gradlew build`。\n\n  **GradleWrapper 的执行流程**：\n\n  当首次执行 `./gradlew build` 命令时，`gradlew` 脚本会读取 `gradle-wrapper.properties` 文件以获取配置信息。该文件指定了所需的 Gradle 版本以及下载和解压 Gradle 发行版的地址。具体步骤如下：\n\n  1. `gradlew` 脚本根据 `gradle-wrapper.properties` 文件中指定的版本信息，自动下载对应的 Gradle 发行版。\n  2. 下载的 Gradle 发行版会被解压到 `GRADLE_USER_HOME` 目录下的 `wrapper/dists` 子目录中。如果未设置 `GRADLE_USER_HOME`，则默认使用用户主目录下的 `.gradle` 目录。\n  3. 在执行构建过程中，Gradle 会创建本地缓存，这些缓存位于 `GRADLE_USER_HOME` 目录下的 `caches` 子目录中。这样，当再次使用相同版本的 Gradle 时，就无需重新下载，可以直接利用本地缓存。\n  4. 之后，每次执行 `./gradlew` 命令时，都会使用 `gradle-wrapper.properties` 文件中指定的 Gradle 版本来执行任务，确保了项目构建的一致性和可复现性。\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921278-18.png)\n\n   \n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921278-19.png)\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921278-20.png)\n\n  如果像我一样遇到超时问题。\n\n  ![img](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw2101713155921278-21.png)\n\n  gradle-wrapper.properties 文件解读:\n\n  | 字段名           | 说明                                               |\n  | ---------------- | -------------------------------------------------- |\n  | distributionBase | 下载的Gradle压缩包解压后存储的主目录               |\n  | distributionPath | 相对于distributionBase的解压后的Gradle压缩包的路径 |\n  | zipStoreBase     | 同distributionBase，只不过是存放zip压缩包的        |\n  | zipStorePath     | 同distributionPath，只不过是存放zip压缩包的        |\n  | distributionUrl  | Gradle发行版压缩包的下载地址                       |\n\n  **使用 Gradle Wrapper (gradlew) 的场景：**\n\n  - 当您下载或克隆一个项目时，通常应该使用该项目提供的 Gradle Wrapper (`gradlew` 或 `gradlew.bat`)。这是因为 Wrapper 确保了项目使用正确的 Gradle 版本来构建，这样可以避免由于 Gradle 版本不兼容导致的构建失败。\n  - 当您要操作之前自己写的不同版本的 Gradle 项目时，也应该使用相应项目的 Gradle Wrapper，以确保每个项目都能以其所需的 Gradle 版本运行。\n\n  **使用本地 Gradle 的场景：**\n\n  - 当您新建一个项目时，如果您没有特别的版本要求，可以使用本地安装的 Gradle。在这种情况下，您可以直接使用 `gradle` 命令来执行构建任务。但是，建议为新的项目也生成一个 Gradle Wrapper，这样项目就可以独立于开发者的本地 Gradle 环境了。\n  - 如果您需要在项目中使用特定版本的 Gradle，或者想要确保项目在任何环境下都能以相同的方式构建，那么即使是新项目，也应该使用 Gradle Wrapper。 总的来说，除非有特殊原因需要使用特定版本的 Gradle，否则使用 Gradle Wrapper 是一个更好的选择，因为它提供了构建的一致性和便利性。\n","category":"文章","cover":"https://pic.code-nav.cn/post_cover/1620630456775032833/TYbsLFfz-PixPin_2024-04-15_08-44-17.png","language":null,"externalLink":null,"shortLink":null,"componentName":null,"viewNum":14,"thumbNum":1,"favourNum":1,"commentNum":0,"priority":0,"userId":"1620630456775032833","reviewStatus":1,"reviewMessage":null,"reviewerId":null,"reviewTime":null,"createTime":"2024-04-15 09:39:23","updateTime":"2024-04-19 16:58:05","user":{"id":"1620630456775032833","planetCode":"3790","userName":"叫我阿杰好了","userAvatar":"https://pic.code-nav.cn/user_avatar/1620630456775032833/VD8sEpIL-微信图片_20230523085336.jpg","gender":1,"userProfile":"目前技术社交账号，CSDN JAVA领域优秀创作者，阿里云专家博主。\n微信公众号：叫我阿杰好了","userRole":"vip","interests":["资源","Java","GitHub","面试题"],"place":null,"birthday":null,"school":null,"major":null,"education":null,"graduationYear":null,"jobStatus":"已工作","company":null,"job":"后端","workYear":3,"direction":null,"goal":null,"github":null,"blog":"https://blog.csdn.net/weixin_53041251?spm=1000.2115.3001.5343","score":35,"coin":20,"followeeNum":1,"followNum":1,"followStatus":null,"vipExpireTime":"2025-03-12 23:57:24","lastLoginTime":null,"createTime":"2023-02-01 11:49:45","updateTime":"2024-04-15 10:12:45"},"tags":["文章","Java","后端","教程"],"fileList":null,"videoList":[],"atUserList":null,"pictureList":null,"hasThumb":false,"hasFavour":false,"needVip":null,"atUserVOList":null}],"total":"4235","size":"8","current":"1","orders":[],"optimizeCountSql":true,"searchCount":true,"countId":null,"maxLimit":null,"pages":"530"},"message":"ok"}